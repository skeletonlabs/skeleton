---
layout: '@layouts/LayoutDoc.astro'
title: Components
description: Guidelines for contributing new Skeleton components.
order: 10
---

export const components = componentSet;

### Dev Server

To run all packages/playgrounds/sites in watch mode, use the following command in the monorepo root:

```shell
pnpm dev
```

### Server Ports

The following represents the _default_ localhost address and port for each project. This will be displayed in the terminal when starting each dev server.

- Documentation Site: `http://localhost:4321/`
- SvelteKit Playground: `http://localhost:5173/`
- NextJS Playground: `http://localhost:3000/`

You may run the sites and playgrounds in parallel at the same time. If a server shares a port, this will increment by one for the next server (ex: `5174`, `5175`, etc). Keep your eye on the terminal to retrieve the specific local address for each.

### Zag.js

Skeleton components are built using a foundation of [Zag.js](https://zagjs.com/). This provides a suite of headless component primitives that handle logic and state, while providing a universal set of features per all supported frameworks. The Skeleton design system is then implemented as a layer on top of this.

When introducing a new Skeleton component, please refer to the documentation for each respective framework. For example:

- Avatar (React): https://zagjs.com/components/react/avatar
- Avatar (Svelte): https://zagjs.com/components/svelte/avatar

Continue reading below to learn how implement the Zag primitives as components using Skeleton-specific conventions.

---

## Adding Components

### Anatomy

When creating a component, start by breaking it down into its core parts. If the component utilizes a [Zag primitive](https://zagjs.com/components/svelte/avatar), you may copy the source [directly from Zag's Usage section](https://zagjs.com/components/svelte/avatar#usage). For custom in-house components, you may use Skeleton's common terminology and discuss the potential anatomy with the Skeleton team.

For example, the Zag Avatar component utilizes the following DOM structure:

```html
<div>
	<img />
	<span>...</span>
</div>
```

As such, we'll implement one component part respective of each element:

- `<Avatar>`
- `<Avatar.Image>`
- `<Avatar.Fallback>`

### Directory and File Names

Components are housed in the following location per framework:

| Framework | Directory         |
| --------- | ----------------- |
| React     | `/src/components` |
| Svelte    | `/src/components` |

Skeleton uses a consistent naming convention per component:

```
avatar/
├── anatomy/
│   ├── avatar-fallback.{tsx|svelte}
│   ├── avatar-image.{tsx|svelte}
│   └── avatar-root.{tsx|svelte}
├── modules/
│   ├── anatomy.ts
│   ├── context.ts
│   └── types.ts
└── index.ts
```

### Anatomy Folder

The anatomy folder contains each component part inside a seperate file.

### Modules Folder

#### Anatomy File

The `anatomy.ts` file contains the exported anatomy, which enables the friendly dot notation syntax when consumed.

```ts title="anatomy.ts"
import AvatarRoot from '../anatomy/avatar-root.js';
import AvatarImage from '../anatomy/avatar-image.js';
import AvatarFallback from '../anatomy/avatar-fallback.js';

const Avatar = Object.assign(
	AvatarRoot, // <Avatar>
	{
		Image: AvatarImage, // <Avatar.Image>
		Fallback: AvatarFallback // <Avatar.Fallback>
	}
);

export { Avatar };
```

#### Types File

The `types.ts` file contains the exported types for each component context and part:

```ts title="types.ts"
import * as avatar from '@zag-js/avatar';
import type { ComponentProps, PropsWithChildren } from 'react';
import type { PropsWithElement } from '../../../internal/props-with-child.js';

// Context Types ---

interface AvatarContext {
	/** Implements the Avatar API */
	api: avatar.Api;
}

// Component Props Types ---

interface AvatarRootProps
	extends PropsWithChildren,
		PropsWithElement,
		Omit<avatar.Props, 'id'>,
		Omit<ComponentProps<'div'>, 'id' | 'dir'> {}

interface AvatarImageProps extends PropsWithElement, ComponentProps<'img'> {}

interface AvatarFallbackProps extends PropsWithChildren, PropsWithElement, ComponentProps<'span'> {}

export type {
	AvatarRootContext
	AvatarRootProps
	AvatarImageProps
	AvatarFallbackProps
};
```

- Component Context types should use the naming convention: `{Component}{Part}Context`
- Component prop types should use the naming convention: `{Component}{Part}Props`
- Use `Omit<>` to avoid conflicting Zag props; such as `id`, which is set automatically within components.
- Use [JSDoc comment blocks](https://jsdoc.app/) to document the intended usage.
- React-Only: Implement `PropsWithChildren` for components that contain a child slot.
- React-Only: Implement `ComponentProps` to describe the DOM element (ex: Img, Button, etc)

#### Context File

The `context.ts` file contains the exported context for each part's context. This pattern enables strong typing.

```ts title="context.ts"
import { createContext } from 'react';
import type { AvatarContext as AvatarContextType } from './types.js';

const AvatarContext = createContext<AvatarContextType>(null!);

export { AvatarContext };
```

---

## Using Zag Primitives

### Source Code

Locate the respective framework component source code on the Zag website. Here's Avatars for example:

| Framework | Directory                                                       |
| --------- | --------------------------------------------------------------- |
| React     | [Avatar Docs](https://zagjs.com/components/react/avatar#usage)  |
| Svelte    | [Avatar Docs](https://zagjs.com/components/svelte/avatar#usage) |

In most cases, Zag provides all source code in a single file. Take care when splitting this into multiple component parts. We recommend starting with the root component - including the primitive imports, and defining the `machine` and `api`. Then utilize Context API and child components for the innards.

### Context API

In some cases you may need to pass data from parent down to child components. For this, we can utilize each framework's Context API:

| Framework | Documentation                                                                                               |
| --------- | ----------------------------------------------------------------------------------------------------------- |
| React     | [View Component API docs](https://svelte.dev/docs/kit/state-management#Using-state-and-stores-with-context) |
| Svelte    | [View Component API docs](https://react.dev/learn/passing-data-deeply-with-context)                         |

Note that Skeleton implements a [set convention for Context API](/docs/resources/contribute/components#context-file) to enable strong typing.

### Common Conventions

While each component will present a unique set of challenges, we recommend you reference other existing components to understand how they were implemented. But there are a few common conventions we'll detail below.

- Try to stick as close to the Zag implementation as possible; don't get creative.
- Avoid hardcoded english text or icons. Consider pass-throughs using props, snippets, or sub-components.
- React-Only: Replace the hardcoded `id` with `useId()`
- Svelte-Only: Replace the hardcoded `id` with `$props.id()`

---

## Styling Components

Styles are common and shared between all framework iterations of the same component. These reside in the `skeleton-common` package and are named to match their respective component.

```
packages/
└── skeleton-common/
	└── src/
		└── classes/
			├── accordion.ts
			├── avatar.ts
			└── ...
```

Here's an example of the Avatar styles found in `avatar.ts`:

```ts title="avatar.ts"
export const classesAvatar = {
	root: 'isolate bg-surface-400-600 size-16 rounded-full overflow-hidden',
	image: 'w-full object-cover',
	fallback: 'size-full flex justify-center items-center'
};
```

- Use the naming convention of `classes{Component}`
- Create a key for each component part.
- Set the value to each component's default class list.

### Style Prefix

It's worth noting that during build time, Skeleton will automatically prefix each class in the class list with `skb:`. The purpose of this prefix is to assign each class to the Tailwind `@base` layer, ensuring user-provided classes take precedence over these classes. This is accomplished using the following Tailwind custom variant.

```css title="base.css"
@custom-variant skb {
	@layer base {
		@slot;
	}
}
```

> NOTE: This is implemented in `/packages/skeleton/src/variants/base.css`

### Importing Class Lists

For Zag primitives, you can import and implement each class list Using Zag's `mergeProps` utility for attributes.

```tsx title="avatar-root.tsx" {1,2,9}
import { mergeProps } from '@zag-js/react';
import { classesAvatar } from '@skeletonlabs/skeleton-common';

export default function (props: AvatarRootProps) {
	// ...

	const attributes = mergeProps(
		// api.getRootProps(),
		{ className: classesAvatar.root }
		// restAttributes
	);

	// return();
}
```

The process is similar for custom components. Even if they don't introduce Zag primitives, we can still use the Zag `mergeProps` utility.

```tsx title="navigation-root.tsx"
code example here
```

## Component Exports

Finally, make sure to implement the expoorts for each respective component's framework package. This is handled in `/src/index.ts`.

```ts
export * from './components/accordion/index.js';
export * from './components/avatar/index.js';
// ...
```

## Additional Resources

- [Component Party](https://component-party.dev/) - easily compare features between each framework
- [React Documentation](https://react.dev/) - the React documentation website.
- [Svelte Documentation](https://svelte.dev/) - the Svelte documentation website.
