---
layout: '@layouts/LayoutDoc.astro'
title: Dynamic Theme Loading (SvelteKit)
description: Load skeleton themes on demand.
showDocsUrl: true
pubDate: 2025-01-18
tags: ['theme', 'guides']
---

export const components = componentSet;

## About Themes

The most common way to load skeleton themes is by importing them in your root stylesheet.

```css title="src/app.css"
@import 'tailwindcss';

@import '@skeletonlabs/skeleton';
@import '@skeletonlabs/skeleton/themes/cerberus';
@import '@skeletonlabs/skeleton/themes/catppuccin';
```

This will bundle your themes when you build your application, for that reason you should only import the themes you need because they will increase your CSS bundle size.

While this is sufficient for most applications this might not be flexible enough for your needs, you may want themes to be
user specific, editable, organization specific and so on, since skeleton themes are just CSS variables there are many ways
you can load themes on demand, read further to see how.

## Creating Stylesheets on layout load

This approach assumes the CSS variables of the skeleton theme you want is available during the load function (eg: on your database or in memory).

In this example we will add a default theme that that can be used as a fallback.

```css title="src/app.css"
@import 'tailwindcss';

@import '@skeletonlabs/skeleton';
@import './default.css';
```

```css title="src/default.css"
[data-theme='default'] {
	/* ... */
}
```

The next step will be to dynamically generate the CSS variables based on the available themes, for this example we will use a mock function but you should replace this with your own implementation that for example fetches a remote datasource like a datbase.

```ts title="src/route/+layout.server.ts"
import type { PageLoad } from './$types';

/**
 * Mocked function
 */
const getThemes = async () => {
	return [
		{
			name: 'theme-1',
			css: `[data-theme='theme-1'] { /* ... */ }`
		},
		{
			name: 'theme-2',
			css: `[data-theme='theme-2'] { /* ... */ }`
		}
	];
};

export const load: PageLoad = async (event) => {
	const themes = getThemes();
	return {
		themes: ['default', ...themes.map((t) => t.name)],
		styleTag: `<style>${themes.map((theme) => theme.css).join('\n\n')}</style>`
	};
};
```

This will process your themes and return a list of theme names and a style tag with the CSS variables of the themes:

```html
<style type="text/css">
	[data-theme='theme-1'] {
		/* ... */
	}

	[data-theme='theme-2'] {
		/* ... */
	}
</style>
```

> ⚠️ _Important_ make sure you sanitize the CSS before inserting it or you'll be vulernable to CSS injection.

Finally insert the `styleTag` into your page using `<svelte:head>`.

```svelte title="src/routes/+layout.svelte"
<script>
	const { data } = $props();
</script>

<svelte:head>
	{@html data.styleTag}
</svelte:head>
```

Note that there are multiple ways to go about this problem, another way could be to generate CSS files with
the same content as the one in this example and then load only the css files you want, while this
is more complex than storing and retrieving themes as JSON on a database this approach could benefit
from the browser caching mechanism.
